---
title: "DataProcessing"
author: "Alex van den Berg"
output:
  html_document:
    toc: true
    theme: united
    highlight: tango
date: "`r Sys.Date()`"
runtime: shiny
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(data.table)
library(RColorBrewer)
library(ggplot2)
library(ggpubr)
library(plyr)
library(dplyr)
library(readxl)
library(rstatix)
library(plotrix)
library(car)
library(Rmisc)
#library(ggrepel)

# boxplots?
library(tidyr)
#library(tidyverse)
library(devtools)
library(ggpattern) # To differentiate when printing in black and white
  # install.packages("devtools")
  # devtools::install_github("coolbutuseless/ggpattern")
  # make sure RTools is installed: https://cran.r-project.org/bin/windows/Rtools/rtools42/rtools.html

#LMER stuff
library(lme4)
library(emmeans)
library(sjstats)
library(lmerTest)
library(MuMIn)

# saving figures
library(svglite)

# File importing / reading
library(jsonlite) # for json files

# Reshaping data for questionnaires
library(reshape2)

# For the rotation matrices
library(geometry)
```

(Optional) clear the environment
```{r}
rm(list=ls())  # clear objects
cat("\014")  # clear console
```

## Loading in the Data

### Obtaining the paths & participant details

First, we get list of all participants, which are saved into folders in data directory.

```{r}
dataFolder = file.path(".","data")
participants = list.dirs(path = dataFolder, full.names = FALSE, recursive = FALSE)
participants

getPdir = function(pnum){ 
  return(file.path(dataFolder, pnum))
}

#getPdir(participants[1]) # example usage
```

The experimental conditions are saved in terms of the [UXF settings](https://github.com/immersivecognition/unity-experiment-framework/wiki). In the settings file, one of the parameters: `first` determined whether the VFD condition was done first (`first==TRUE`) or second (`first==FALSE`). 

We will also need the participant details from this same folder, which include the demographic data

```{r}
getPsettingsFile = function(pnum){ 
  return(file.path(getPdir(pnum),"session_info","settings.json"))
}

# If true, the participant started with noise VFD enabled, otherwise without it enabled
getPsetting <- function(pnum, settingName) {
  # get the path to the settings file for the participant
  settingsFile <- getPsettingsFile(pnum)
  # read the json file into a list
  settings <- jsonlite::fromJSON(settingsFile)
  
  # retrieve the value of the specific detail
  settingValue <- settings[[settingName]][1]
  
  return(settingValue)
}

# If true, the participant started with noise VFD enabled, otherwise without it enabled
startedWithNoise <- function(pnum) {
  return(getPsetting(pnum,"first"))
}

#startedWithNoise(participants[1])

getPdetail <- function(pnum, detailName) {
  # get the path to the details file for the participant
  detailsFile <- file.path(getPdir(pnum),"session_info","participant_details.csv")
  
  # read the csv file into a data frame
  details <- read.csv(detailsFile)
  
  # retrieve the value of the specific detail
  detailValue <- details[[detailName]][1]
  
  return(detailValue)
}

#getPdetail(participants[1],"age") # example usage
```

### Get the tracking data

We'll need the paths to the [trackers](https://github.com/immersivecognition/unity-experiment-framework/wiki/Data-collection). Which contain all the data which is tracked for each of the trials. The same tracker names are used for each participant for each session (condition in this case), so we'll just get a list we can refer back to later. Additionally, we'll define another function to get a certain tracker dataset for a selected participant.

```{r}
trackerPath = file.path(getPdir(participants[1]),"trackers")
trackers = list.files(path = trackerPath, full.names = FALSE)
trackers # use one of the participants to get the different file names for all the tracker files.

# we make a list of the filenames so we can easily call them without writing the whole filename
filenameDict <- list(
  "leftfoot" = "leftfoot_tracker_movement_T",
  "loko_lokodata" = "loko_lokodata_T",
  "rightfoot" = "rightfoot_tracker_movement_T",
  "tmleft" = "tmleft_tracker_movement_T",
  "tmright" = "tmright_tracker_movement_T",
  "vivetrackers" = "vivetrackers_SteamVRData_T"
)

# get any type of data
getTdata <- function(pnum, trackerType, trialNumber) {
  
  # Construct filename from filenamePattern and participantNumber
  filename <- paste0(filenameDict[[trackerType]], sprintf("%03d", trialNumber), ".csv")
  
  # Construct full file path
  filePath <- file.path(getPdir(pnum),"trackers",filename)
  
  # Check if the file exists
  if(!file.exists(filePath)) {
    stop("The specified file does not exist.")
  }
  
  # Read the data from the csv file
  data <- read.csv(filePath)
  
  return(data)
}

#getTdata(participants[1],"leftfoot",TRUE) # example usage
```


### Get the Questionnaire data
The questionnaire data is in a separate file. First, we write some methods to extract the data.
```{r}
questionnaireInfoFolder = file.path(".","questionnaires")

getQfile = function(pnum,qType){ # qType = IMI / SSQ / VEQ
  return(file.path(getPdir(pnum),"questionnaires",paste0("questionnaireID_",qType,"_ALL_answers.csv")))
}

getQdata <- function(pnum) {
  # Get the path to the questionnaire file for the participant
  questionnaireFile <- getQfile(pnum, "disturbanceExperiment")
  
  # Read the CSV file into a data frame
  questionnaire <- read.csv(questionnaireFile)
  
  # Identifying the columns with answers
  answerColumns <- grep("Answer_", names(questionnaire), value = TRUE)
  
  # Dynamically extract and label the data based on trial numbers
  result <- data.frame(QuestionID = questionnaire$QuestionID)
  for (i in seq_along(answerColumns)) {
    columnName <- paste0("Trial_", i)
    result[[columnName]] <- questionnaire[[answerColumns[i]]]
  }
  
  return(result)
}


#getQdata(participants[1])# example usage
```
We extract this data and calculate some resulting scores each questionnaire. We then add the questionnaire data to our distances data table.

First, we define a method to extract some info about the questionnaires, and then use that info to calculate the scores for a specific participants and questionnaire:

```{r}
getQuestionInfo <- function(qType) { # qType = IMI / SSQ / VEQ
  qInfopath = file.path(questionnaireInfoFolder,paste0(qType,".csv"))
  # Read the CSV file into a data frame
  questionnaire <- read.csv(qInfopath)
  return(questionnaire)
}

computeScores <- function(pnum) {
  qdata = getQdata(pnum)
  
  qinfo = getQuestionInfo("disturbanceExperiment")
  combined <- merge(qdata, qinfo, by = "QuestionID")

  # Find trial columns
  trialColumns <- grep("Trial_", names(combined), value = TRUE)

  # Initialize an empty list to store scores for each trial
  allScores <- list()

  # Loop through each trial column to calculate scores
  for (trialCol in trialColumns) {
    # Mirror the scores if needed
    combined[[trialCol]] <- ifelse(combined$mirror, 8 - combined[[trialCol]], combined[[trialCol]])

    # Compute the scores for each category for the trial
    scoresTrial <- tapply(combined[[trialCol]], combined$category, mean, na.rm = TRUE)

    # Compute the total score for the trial
    scoresTrial["total"] <- mean(scoresTrial, na.rm = TRUE)
    
    # Store the calculated scores in the list
    allScores[[trialCol]] <- scoresTrial
  }
  
  return(allScores)
}

#computeScores(participants[1])# example usage
```

Now we can use this method to make a dataframe to get all scores for all the participants.

```{r}
calculateAllScores <- function(participants) {
  # Initialize an empty list to hold results for each trial
  allScores <- list()

  # Iterate over the participants
  for (participant in participants) {
    # Compute the scores for the participant
    participantScores <- computeScores(participant)
    
    # Iterate over each trial's scores
    for (trial in names(participantScores)) {
      trialScores <- participantScores[[trial]]

      # Transform the scores into a data frame with a single row and bind it with the participant ID
      trialRow <- cbind(participant = participant, as.data.frame(t(trialScores)))

      # If the trial doesn't exist in allScores, initialize it
      if (!trial %in% names(allScores)) {
        allScores[[trial]] <- data.frame()
      }

      # Add the scores to the corresponding trial in allScores
      allScores[[trial]] <- rbind(allScores[[trial]], trialRow)
    }
  }
  
  # Reshape and combine all trials' data
  combinedData <- do.call(rbind, lapply(names(allScores), function(trial) {
    cbind(Trial = trial, allScores[[trial]])
  }))
  
  return(combinedData)
}

#calculateAllScores(participants) # example use
```


## Pre-processing

### Extract trial data
We first find the start and end times for each trial and each participant

```{r}
findTrialTimes <- function(participant, trialNumber) {
  # Retrieve trial start and end times from loko_lokodata
  lokoData <- getTdata(participant, "loko_lokodata", trialNumber)
  
  # Identifying the index where trialStarted turns to 1
  startIndex <- which(lokoData$trialStarted == 1)[1]
  # Identifying the index where trialStarted turns back to 0
  endIndex <- tail(which(lokoData$trialStarted == 1), 1) # this grabs the last time this happens, if there are multiple trials within the same datafile (which shouldn't happen), this is not accounted for

  # Extracting time and Lokotime at the start and end of the trial
  trialStartTime <- lokoData$time[startIndex]
  trialStartLokotime <- lokoData$Lokotime[startIndex]
  trialEndTime <- lokoData$time[endIndex]
  trialEndLokotime <- lokoData$Lokotime[endIndex]

  # Save the start and end times for later use or analysis
  trialTimes <- data.frame(
    Start_Time = trialStartTime, 
    Start_Lokotime = trialStartLokotime,
    End_Time = trialEndTime,
    End_Lokotime = trialEndLokotime
  )
  
  return(trialTimes)
}

# Example usage
#findTrialTimes(participants[1], 1)
```

### Tracker data

All tracker data is recorded in the vivetracker csv. The others are just for backup but aren't used right now. We extract the relevant data by matching the timepoints in the lokodata.

```{r}
getTrackerDataForTrial <- function(participant, trialNumber) {
  # Retrieve the trial times using findTrialTimes
  trialTimes <- findTrialTimes(participant, trialNumber)
  
  # Get the tracker data
  trackerData <- getTdata(participant, "vivetrackers", trialNumber)
  
  # Filter the tracker data based on trial start and end times
  filteredTrackerData <- trackerData[
    trackerData$systemTime >= trialTimes$Start_Time & trackerData$systemTime <= trialTimes$End_Time, 
    ]
  
  return(filteredTrackerData)
}

# Example usage
#getTrackerDataForTrial(participants[1], 1)
```

### Find transformation matrices

y = up
z = 

```{r}
quaternionToRotationMatrix <- function(q) {
    # Ensure the quaternion is normalized
    q <- q / sqrt(sum(q^2))
    
    w <- q[1]
    x <- q[2]
    y <- q[3]
    z <- q[4]

    # Compute the elements of the rotation matrix
    rotMatrix <- matrix(c(
        1 - 2 * y^2 - 2 * z^2, 2 * x * y - 2 * z * w, 2 * x * z + 2 * y * w,
        2 * x * y + 2 * z * w, 1 - 2 * x^2 - 2 * z^2, 2 * y * z - 2 * x * w,
        2 * x * z - 2 * y * w, 2 * y * z + 2 * x * w, 1 - 2 * x^2 - 2 * y^2
    ), nrow = 3, byrow = TRUE)

    # Append a fourth row and column for homogeneous coordinates
    rotMatrix <- rbind(rotMatrix, c(0, 0, 0))
    rotMatrix <- cbind(rotMatrix, c(0, 0, 0, 1))

    return(rotMatrix)
}


calculateTransformationMatrix <- function(trackerData) {
  # Calculate the average position of the trackers over the first 100 frames
  avgLeftPos <- colMeans(trackerData[1:100, c("TreadmillLeft.pos.x", "TreadmillLeft.pos.y", "TreadmillLeft.pos.z")])
  avgRightPos <- colMeans(trackerData[1:100, c("TreadmillRight.pos.x", "TreadmillRight.pos.y", "TreadmillRight.pos.z")])

  # New origin is the midpoint of the average positions
  newOrigin <- (avgLeftPos + avgRightPos) / 2

  # Calculate the average rotation (quaternion) of the trackers
  avgLeftRot <- colMeans(trackerData[1:100, c("TreadmillLeft.rot.w", "TreadmillLeft.rot.x", "TreadmillLeft.rot.y", "TreadmillLeft.rot.z")])
  avgRightRot <- colMeans(trackerData[1:100, c("TreadmillRight.rot.w", "TreadmillRight.rot.x", "TreadmillRight.rot.y", "TreadmillRight.rot.z")])
  ### NOTE: order=WXYZ

  # Combine and normalize the average rotations to define the new orientation
  newOrientation <- (avgLeftRot + avgRightRot) / 2
  newOrientation <- newOrientation / sqrt(sum(newOrientation^2))

  # Convert the average quaternion to a rotation matrix
  newRotMatrix <- quaternionToRotationMatrix(newOrientation)

  # Create the translation matrix
  translationMatrix <- diag(4)
  translationMatrix[1:3, 4] <- -newOrigin

  # Combine the rotation and translation into a single transformation matrix
  transformationMatrix <- newRotMatrix %*% translationMatrix

  return(transformationMatrix)
}

# Example usage with your tracker data
#calculateTransformationMatrix(getTrackerDataForTrial(participants[1], 1))
```

### Return the transformed data

```{r}
transformTrackerData <- function(participant, foot, trialNumber, startTime = 0, endTime = 130) {
    # Retrieve the tracker data for the specified trial and participant
    trackerData <- getTrackerDataForTrial(participant, trialNumber)

    # Calculate the transformation matrix
    transformationMatrix <- calculateTransformationMatrix(trackerData)

    # Select the appropriate columns based on the specified foot
    if (foot == "left") {
        footColumns <- c("LeftFoot.pos.x", "LeftFoot.pos.y", "LeftFoot.pos.z")
    } else if (foot == "right") {
        footColumns <- c("RightFoot.pos.x", "RightFoot.pos.y", "RightFoot.pos.z")
    } else {
        stop("Invalid foot specified. Choose either 'left' or 'right'.")
    }

    # Extract the foot position data and transform it
    footData <- trackerData[, footColumns]
    transformedData <- t(apply(footData, 1, function(pos) {
        # Add a 1 for homogeneous coordinates
        posHomogeneous <- c(pos, 1)
        # Apply the transformation
        transformedPos <- transformationMatrix %*% posHomogeneous
        return(transformedPos[1:3])
    }))

    # Extract system time and adjust it relative to the first sample
    systemTime <- trackerData$systemTime - trackerData$systemTime[1]

    # Combine system time with transformed data
    transformedDataFrame <- cbind(systemTime, as.data.frame(transformedData))
    colnames(transformedDataFrame) <- c("time", "pos.x", "pos.y", "pos.z")

    # Filter data based on the provided start and end times
    filteredData <- transformedDataFrame[transformedDataFrame$time >= startTime & transformedDataFrame$time <= endTime,]

    # Return the filtered data
    return(filteredData)
}

# Example usage
transformTrackerData(participants[1], "left", 1)
```

### Plot trajectories

First thing to do is check if our transform works. Easiest way to verify is to plot the trajectories:

```{r,echo=FALSE}
xOptions = c("time", "pos.x", "pos.y", "pos.z")

inputPanel(
  selectizeInput("participant", "Participant", 
                choices = participants, selected = participants[1], multiple = FALSE),
  numericInput("TrialNumber", "Trial Number", 
                min = 1, max = Inf, value = 1, step = 1),
  selectizeInput("foot", "Foot", 
                choices = c("left", "right"), selected = "left", multiple = FALSE),
  selectizeInput("xplot", "X-axis", 
                choices = xOptions, selected = xOptions[1], multiple = FALSE),
  selectizeInput("yplot", "Y-axis", 
                choices = xOptions, selected = xOptions[2], multiple = FALSE),
  numericInput("plotheight", "Plot Height",
            min = 50, max = Inf, value = 500, step = 50),
  numericInput("start", "Start Time",
              min = 0, max = 500, value = 0, step = 1),
  numericInput("end", "End Time",
              min = 0, max = 500, value = 120, step = 1)
)

makeLinePlot = reactive({
  transformedData <- transformTrackerData(input$participant, input$foot, input$TrialNumber, input$start, input$end)

  # Create plot
  return(plotTransformedData(transformedData, input$xplot, input$yplot))
})

renderPlot({
  makeLinePlot()
}, height = reactive(input$plotheight))

plotTransformedData <- function(transformedData, x_axis = "time", y_axis = "pos.x") {
  p <- ggplot(data=transformedData, aes_string(x = x_axis, y = y_axis)) +
    geom_path() +
    labs(x = x_axis, y = y_axis)

  return(p)
}

```

## Plotting

Click here to save the figures
```{r, echo=FALSE}
inputPanel(
  actionButton("save", "Save figures")
)
```